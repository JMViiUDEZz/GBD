SET SERVEROUTPUT ON;

1.
true
false
null
true
null
null
true
false
null
null
false
false

2.
DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=6;
 V2:=-6;
 IF V1>V2 THEN
  DBMS_OUTPUT.PUT_LINE('EL MAYOR ES: '||V1);
 ELSIF V2>V1 THEN
  DBMS_OUTPUT.PUT_LINE('EL MAYOR ES: '||V2);
 ELSE 
  DBMS_OUTPUT.PUT_LINE('SON IGUALES');
 END IF;
END;

--ASIGNANDO VALORES A VARIABLES
DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=&V1;
 V2:=&V2;
 IF V1>V2 THEN
  DBMS_OUTPUT.PUT_LINE('EL MAYOR ES: '||V1);
 ELSIF V2>V1 THEN
  DBMS_OUTPUT.PUT_LINE('EL MAYOR ES: '||V2);
 ELSE 
  DBMS_OUTPUT.PUT_LINE('SON IGUALES');
 END IF;
END;

3.
DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=&V1;
 V2:=&V2;
 IF V1>V2 THEN
  DBMS_OUTPUT.PUT_LINE('1'||V1);
 ELSIF V2>V1 THEN
  DBMS_OUTPUT.PUT_LINE('2'||V2);
 ELSE 
  DBMS_OUTPUT.PUT_LINE('x');
 END IF;
END;

4.
DECLARE
 V NUMBER(3) DEFAULT 0;
BEGIN
  WHILE V<100 LOOP
   DBMS_OUTPUT.PUT_LINE(V);
   V := V + 2;
  END LOOP;
END;

BEGIN
 FOR V IN 0..49
  LOOP
   DBMS_OUTPUT.PUT_LINE(V*2);
  END LOOP;
END;

--UTILIZANDO LA FUNCION MOD
QUE NOS DEVUELVE EL RESTO DE UNA DIVISION
BEGIN
 FOR V IN 0..99
  LOOP
   IF MOD(V,2)=0 THEN 
    DBMS_OUTPUT.PUT_LINE(V);
  END IF;
 END LOOP;
END;


5.
DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=&V1;
 V2:=&V2;
 DBMS_OUTPUT.PUT_LINE('LA SUMA DE LOS NUMEROS ES: '||(V1+V2));
END;

DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=&V1;
 V2:=&V2;
 DBMS_OUTPUT.PUT_LINE('LA SUMA DE LOS NUMEROS ES: '||TO_CHAR (V1+V2,''));
END;

--VARIABLE EXTRA LLAMADA SUMA
DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
 SUMA NUMBER (4);
BEGIN
 V1:=&V1;
 V2:=&V2;
 SUMA := V1+V2;
 DBMS_OUTPUT.PUT_LINE('LA SUMA DE LOS NUMEROS ES: '||SUMA);
END;

6.
CREATE OR REPLACE FUNCTION SUMA(N1 NUMBER,N2 NUMBER)
RETURN NUMBER
AS
BEGIN
 RETURN N1+N2;
END;

DECLARE
 V1 NUMBER (2);
 V2 NUMBER (2);
BEGIN
 V1:=&V1;
 V2:=&V2;
 DBMS_OUTPUT.PUT_LINE('LA SUMA DE LOS NUMEROS ES: '||SUMA(V1,V2));
END;

7.
CREATE OR REPLACE PROCEDURE PARES_MENORES_QUE(N NUMBER)
AS
BEGIN
 FOR V IN 0..N/2-1 LOOP
   DBMS_OUTPUT.PUT_LINE(V*2);
  END LOOP;
END;

EXECUTE PARES_MENORES_QUE(100);

--EJERCICIO PROPUESTO NUMEROS PARES ENTRE DOS VALORES
CREATE OR REPLACE PROCEDURE PARES_ENTRE_DOS(N1 NUMBER,N2 NUMBER)
AS
BEGIN
 FOR V IN N1..N2/2-1 LOOP
   DBMS_OUTPUT.PUT_LINE(V*2);
 END LOOP;
END;

CREATE OR REPLACE PROCEDURE PARES_ENTRE_DOS(N1 NUMBER,N2 NUMBER)
AS
 I NUMBER DEFAULT N1;
BEGIN
 FOR I IN N1..N2/2-1 LOOP
  IF THEN
   DBMS_OUTPUT.PUT_LINE(I);
  END IF;
 END LOOP;
END;

CREATE OR REPLACE PROCEDURE PARES_ENTRE_DOS(N1 NUMBER,N2 NUMBER)
AS
 I NUMBER;
BEGIN
 I:=N1;
 WHILE I<=N2 LOOP
  IF MOD(I,2)=0 THEN
   DBMS_OUTPUT.PUT_LINE(I);
  END IF;
 I:=I+1;
 END LOOP;
END;

--SUPONIENDOSE QUE LA N1 PODRIA SER MAS GRANDE QUE N2
CREATE OR REPLACE PROCEDURE PARES_ENTRE_DOS(N1 NUMBER,N2 NUMBER)
AS
 I NUMBER;
 J NUMBER;
BEGIN
 IF N1<=N2 THEN
 I:=N1;
 J:=N2;
 ELSE
 J:=N1;
 I:=N2;
  END IF;
 WHILE I<=J LOOP
  IF MOD(I,2)=0 THEN
   DBMS_OUTPUT.PUT_LINE(I);
  END IF;
 I:=I+1;
 END LOOP;
END;

EXECUTE PARES_ENTRE_DOS(10,3);
EXECUTE PARES_ENTRE_DOS(3,10);

8.
CREATE OR REPLACE PROCEDURE ES_PRIMO(N NUMBER)
AS
 PRIMO BOOLEAN:=TRUE;
 I NUMBER:=2;
BEGIN
 WHILE I<=N-1 AND PRIMO=TRUE LOOP
  IF MOD(N,I)=0 THEN
   PRIMO:=FALSE;
  END IF;
I:=I+1; 
 END LOOP;
 IF PRIMO=TRUE THEN
 DBMS_OUTPUT.PUT_LINE('ES PRIMO');
 ELSE
  DBMS_OUTPUT.PUT_LINE('NO ES PRIMO');
 END IF;
END;

EXECUTE ES_PRIMO(11);


--SE PUEDE PONER EXECUTE O LLAMAR AL PROGRAMA CON:
DECLARE
 A NUMBER;
BEGIN
 A:=&A;
 ES_PRIMO(A);
END;

9.
CREATE OR REPLACE PROCEDURE MOSTRAR_DATOS_FECHA(F DATE)
AS
BEGIN
 DBMS_OUTPUT.PUT_LINE('EL DÍA ES: '||TO_CHAR(F,'DAY, DD'));
 DBMS_OUTPUT.PUT_LINE('EL MES ES: '||TO_CHAR(F,'MONTH, MM'));
 DBMS_OUTPUT.PUT_LINE('EL AÑO ES: '||TO_CHAR(F,'YYYY'));
END;

EXECUTE MOSTRAR_DATOS_FECHA(SYSDATE)

10.
CREATE OR REPLACE FUNCTION MESES_ENTRE_FECHAS(F1 DATE,F2 DATE)
RETURN NUMBER
AS
BEGIN
 RETURN TRUNC(MONTHS_BETWEEN(F1,F2));
END;

SELECT MESES_ENTRE_FECHAS(SYSDATE,SYSDATE) FROM DUAL

CREATE OR REPLACE FUNCTION ANNOS_ENTRE_FECHAS(F1 DATE,F2 DATE)
RETURN NUMBER
AS
BEGIN
 RETURN TRUNC(MONTHS_BETWEEN(F1,F2)/12);
END;

SELECT ANNOS_ENTRE_FECHAS(SYSDATE,'17-12-2000') FROM DUAL

11.
CREATE OR REPLACE FUNCTION TRIENIOS_ENTRE_FECHAS(F1 DATE,F2 DATE)
RETURN NUMBER
AS
BEGIN
 RETURN TRUNC(ANNOS_ENTRE_FECHAS(F1,F2)/3);
END;

SELECT TRIENIOS_ENTRE_FECHAS(SYSDATE,'17-12-2000') FROM DUAL

12.
CREATE OR REPLACE PROCEDURE BORRAR_EMPLEADO(NE EMPLE.EMP_NO%TYPE)
AS
BEGIN
 DELETE FROM EMPLE WHERE EMP_NO=NE;
 COMMIT;
 DBMS_OUTPUT.PUT_LINE('SE HA BORRADO '||SQL%ROWCOUNT||' EMPLEADO');
END;

EXECUTE BORRAR_EMPLEADO(7369);

13.
--LAS VARIABLES ACUMULADORAS SIEMPRE EMPIEZAN CON EL VALOR 0 AL PRINCIPIO
CREATE OR REPLACE PROCEDURE SUBIR_SALARIO_EMPLEADO(NE EMPLE.EMP_NO%TYPE)
AS
 EMPLEADOS_A_CARGO NUMBER(2);
 SUBIDA NUMBER DEFAULT 0;
 OFI EMPLE.OFICIO%TYPE;
BEGIN
 SELECT COUNT(EMP_NO) INTO EMPLEADOS_A_CARGO FROM EMPLE WHERE DIR=NE;
 CASE EMPLEADOS_A_CARGO
  WHEN 0 THEN
  SUBIDA:=SUBIDA+50;
  WHEN 1 THEN
  SUBIDA:=SUBIDA+80;
  WHEN 2 THEN
  SUBIDA:=SUBIDA+100;
  ELSE
  SUBIDA:=SUBIDA+110;
 END CASE;
 SELECT OFICIO INTO OFI FROM EMPLE WHERE EMP_NO=NE;
 IF  OFI='PRESIDENTE' THEN
  SUBIDA:=SUBIDA+30;
 END IF;
 UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE EMP_NO=NE;
 COMMIT;
EXCEPTION
 WHEN NO_DATA_FOUND THEN
  DBMS_OUTPUT.PUT_LINE('EL EMPLEADO NO EXISTE');
END;

EXECUTE SUBIR_SALARIO_EMPLEADO(7369);

14.
CREATE OR REPLACE FUNCTION PRIMER_APELLIDO(CADENA VARCHAR2)
RETURN VARCHAR2
AS
 APELLIDO VARCHAR2(255) DEFAULT '';
 I NUMBER DEFAULT 1;
BEGIN
 WHILE SUBSTR(CADENA,I,1)<>' ' AND I<=LENGTH(CADENA) LOOP
  APELLIDO:=APELLIDO||SUBSTR(CADENA,I,1);
  I:=I+1;
 END LOOP;
 RETURN APELLIDO;
END;

SELECT PRIMER_APELLIDO('VIUDEZ PARRA') FROM DUAL

15.
CREATE OR REPLACE FUNCTION CADENA_AL_REVES(CADENA VARCHAR2)
RETURN VARCHAR2
AS
 CADENA_INVERTIDA VARCHAR2(255) DEFAULT '';
BEGIN
 FOR I IN REVERSE 1..LENGTH(CADENA) LOOP
  CADENA_INVERTIDA:=CADENA_INVERTIDA||SUBSTR(CADENA,I,1);
 END LOOP;
 RETURN CADENA_INVERTIDA;
END;

SELECT CADENA_AL_REVES('HOLA') FROM DUAL

--ESTA ES LA MISMA FUNCION QUE LA 14, PERO MUESTRA EL
APELLIDO AL REVES
CREATE OR REPLACE FUNCTION PRIMER_APELLIDO_AL_REVES(CADENA VARCHAR2)
RETURN VARCHAR2
AS
 APELLIDO VARCHAR2(255) DEFAULT '';
 I NUMBER DEFAULT 1;
BEGIN
 WHILE SUBSTR(CADENA,I,1)<>' ' AND I<=LENGTH(CADENA) LOOP
  APELLIDO:=SUBSTR(CADENA,I,1)||APELLIDO;
  I:=I+1;
 END LOOP;
 RETURN APELLIDO;
END;

SELECT PRIMER_APELLIDO_AL_REVES('VIUDEZ PARRA') FROM DUAL

16.
CREATE OR REPLACE FUNCTION PALINDROMA(CADENA VARCHAR2)
RETURN BOOLEAN
AS
BEGIN
 RETURN CADENA=CADENA_AL_REVES(CADENA); 
END;

--DARA UN ERROR YA QUE NO SE PUEDE MOSTRAR UN VALOR BOOLEANO,
ES DECIR TRUE O FALSE, CON LA TABLA DUAL
SELECT PALINDROMA('ANA') FROM DUAL

--POR ELLO, SE REALIZARA UN PROGRAMA A PARTE PARA SABER EL RESULTADO FINAL
BEGIN
 IF PALINDROMA('ALBA') THEN
  DBMS_OUTPUT.PUT_LINE('LA PALABRA ES PALINDROMA');
 ELSE
  DBMS_OUTPUT.PUT_LINE('LA PALABRA NO ES PALINDROMA');
 END IF;
END;

17.

--MI FUNCION DE FRASE SIN ESPACIOS
CREATE OR REPLACE FUNCTION CADENA_SIN_ESPACIOS(CADENA VARCHAR2)
RETURN VARCHAR2
AS
 CADENA_SIN_ESPACIO VARCHAR2(255) DEFAULT '';
 I NUMBER DEFAULT 1;
BEGIN
 WHILE I<=LENGTH(CADENA) LOOP
  IF SUBSTR(CADENA,I,1)<>' ' THEN
   CADENA_SIN_ESPACIO:=CADENA_SIN_ESPACIO||SUBSTR(CADENA,I,1);
   I:=I+1;
  ELSE
   I:=I+1;
  END IF;
 END LOOP;
RETURN CADENA_SIN_ESPACIO; 
END;

--FUNCION DE GINES SIN ESPACIOS
SELECT CADENA_SIN_ESPACIOS('TODO JUNTO QUEDA MAS COMPACTO') FROM DUAL

CREATE OR REPLACE FUNCTION CADENA_SIN_ESPACIOS_GINES(CADENA VARCHAR2)
RETURN VARCHAR2
AS
 CADENA_SIN_ESPACIO VARCHAR2(255) DEFAULT '';
 LETRA CHAR(1);
BEGIN
 FOR I IN 1..LENGTH(CADENA) LOOP
  LETRA:=SUBSTR(CADENA,I,1);
  IF LETRA<>' ' THEN
   CADENA_SIN_ESPACIO:=CADENA_SIN_ESPACIO||SUBSTR(CADENA,I,1);
  END IF;
 END LOOP;
RETURN CADENA_SIN_ESPACIO; 
END;

SELECT CADENA_SIN_ESPACIOS_GINES('TODO JUNTO QUEDA MAS COMPACTO') FROM DUAL

--FUNCION QUE PIDE EL EJERCICIO
CREATE OR REPLACE FUNCTION FRASE_PALINDROMA(CADENA VARCHAR2)
RETURN BOOLEAN
AS
BEGIN
 RETURN CADENA_SIN_ESPACIOS_GINES(CADENA)=CADENA_SIN_ESPACIOS_GINES(CADENA_AL_REVES(CADENA)); 
END;

BEGIN
 IF FRASE_PALINDROMA('NO SUBAS ABUSON') THEN
  DBMS_OUTPUT.PUT_LINE('LA PALABRA ES PALINDROMA');
 ELSE
  DBMS_OUTPUT.PUT_LINE('LA PALABRA NO ES PALINDROMA');
 END IF;
END;

18.

--RECURSIVIDAD DE UNA FUNCION: UNA FUNCION SE LLAMA CUANDO ESTA SE ESTÁ CREANDO
AL MISMO TIEMPO
CREATE OR REPLACE FUNCTION FACTORIAL(N NUMBER)
RETURN NUMBER
AS
BEGIN
IF N=1 THEN 
 RETURN 1;
ELSE
 RETURN N*FACTORIAL(N-1);
END IF;
END;

SELECT FACTORIAL(5) FROM DUAL

--TRAZA DE EJECUCIÓN DE LA FUNCION FACTORIAL:
FACTORIAL(5)
N=5
5*FACTORIAL(4)

FACTORIAL(4)
N=4
5*4*FACTORIAL(3)

FACTORIAL(3)
N=3
5*4*3*FACTORIAL(2)

FACTORIAL(2)
N=2
5*4*3*2*FACTORIAL(1)

FACTORIAL(1)
N=1
5*4*3*2*1=120

19.
EJEMPLO DE FUNCION PARA UTILIZAR LA FUNCION FACTORIAL
(CALCULAR EL NUMERO COMBINATORIO)

20.
CREATE OR REPLACE PROCEDURE CAMBIAR_OFICIO_EMPLEADO(
 NE EMPLE.EMP_NO%TYPE,
 NUEVO_OFICO VARCHAR2)
AS
 APE EMPLE.APELLIDO%TYPE;
 OFICIO_ACTUAL EMPLE.OFICIO%TYPE;
BEGIN
 SELECT APELLIDO,OFICIO INTO APE,OFICIO_ACTUAL FROM EMPLE WHERE EMP_NO=NE;
 UPDATE EMPLE SET OFICIO=NUEVO_OFICO WHERE EMP_NO=NE;
 COMMIT;
 DBMS_OUTPUT.PUT_LINE('EL OFICIO '||OFICIO_ACTUAL||' DEL EMPLEADO '||APE||' SE HA CAMBIADO CORRECTAMENTE');
EXCEPTION
 WHEN NO_DATA_FOUND THEN
  DBMS_OUTPUT.PUT_LINE('EL EMPLEADO NO EXISTE');
END;

EXECUTE CAMBIAR_OFICIO_EMPLEADO(7369,'CARPINTERO');

SELECT * FROM EMPLE

21.
CREATE OR REPLACE PROCEDURE CAMBIAR_DEPARTAMENTO_EMPLEADO(
 NE EMPLE.EMP_NO%TYPE,
 ND DEPART.DNOMBRE%TYPE
)
AS
 CD EMPLE.DEPT_NO%TYPE;
 CD2 DEPART.DEPT_NO%TYPE;
 NOM_DEP_ANTIGUO DEPART.DNOMBRE%TYPE;
BEGIN
 SELECT DEPT_NO INTO CD FROM EMPLE WHERE EMP_NO=NE;
 SELECT DEPT_NO INTO CD2 FROM DEPART WHERE DNOMBRE=ND;
 UPDATE EMPLE SET DEPT_NO=CD2 WHERE EMP_NO=NE;
 COMMIT;
 SELECT DNOMBRE INTO NOM_DEP_ANTIGUO FROM DEPART WHERE DEPT_NO=CD;
 DBMS_OUTPUT.PUT_LINE('SE HA CAMBIADO AL EMPLEADO DEL DEPARTAMENTO '
 ||NOM_DEP_ANTIGUO||' AL DEPARTAMENTO '||ND);
EXCEPTION
 WHEN NO_DATA_FOUND THEN
  DBMS_OUTPUT.PUT_LINE('DATOS ERRONEOS');
END;

EXECUTE cambiar_departamento_empleado(7369,'VENTAS');

22.
--ESTE PROGRAMA NO NOS SIRVE DE UTILIDAD, AUNQUE NO ABORTA DEBIDO
A LA EXCEPCION DE SI DEVUELVE DEMASIADAS(MAS DE 1) FILA

CREATE OR REPLACE PROCEDURE VER_APE_FA
AS
 APE EMPLE.APELLIDO%TYPE;
 FA EMPLE.OFICIO%TYPE;
BEGIN
 SELECT APELLIDO,OFICIO INTO APE,FA FROM EMPLE ORDER BY APELLIDO;
EXCEPTION
 WHEN TOO_MANY_ROWS THEN
  DBMS_OUTPUT.PUT_LINE('EL SELECT DEVUELVE MAS DE UNA FILA');
END;

EXECUTE VER_APE_FA;

--POR LO TANTO, SE UTILIZARAN LOS CURSORES. UN CURSOR ES COMO UNA VARIABLE
PERO PUEDE ALMACENAR DIFERENTES CAMPOS/FILAS(COMO UNA TABLA).
TENDRA TANTAS COMO LAS QUE DEVUELVE EL SELECT. CADA FILA TIENE UN CURSOR,
PARA PODER EXTRAER LA FILA DEL CURSOR, Y SE EXTRAE LA QUE ESTÉ APUNTADA POR EL PUNTERO DEL CURSOR.
CUANDO SE EXTRAE LA PRIMERA, EL CURSOR SE DESPLAZA A LA SEGUNDA...(CON EL COMANDO FETCH) ASI HASTA LA ULTIMA.

CREATE OR REPLACE PROCEDURE VER_APE_FA
AS
 CURSOR C IS SELECT APELLIDO,FECHA_ALT FROM EMPLE ORDER BY APELLIDO;
 FILA C%ROWTYPE;
BEGIN
 OPEN C;
  LOOP
    FETCH C INTO FILA;
   EXIT WHEN C%NOTFOUND;
   DBMS_OUTPUT.PUT_LINE(FILA.APELLIDO||' '||FILA.FECHA_ALT);
  END LOOP;
 CLOSE C;
EXCEPTION
 WHEN TOO_MANY_ROWS THEN
  DBMS_OUTPUT.PUT_LINE('EL SELECT DEVUELVE MAS DE UNA FILA');
END;

EXECUTE VER_APE_FA;

--SI SOSPECHAMOS QUE EL SELECT PUEDE DEVOLVER MAS DE 1 FILA,
DEBEREMOS DE UTILIZAR EL CURSOR

23.
CREATE OR REPLACE PROCEDURE VER_EMPLE_DEPART
AS
 CURSOR C IS SELECT DNOMBRE,COUNT(EMP_NO) AS EMPLEADOS 
 FROM EMPLE E RIGHT JOIN DEPART D
 ON E.DEPT_NO=D.DEPT_NO GROUP BY DNOMBRE;
 F C%ROWTYPE;
BEGIN
 OPEN C;
  LOOP
    FETCH C INTO F;
   EXIT WHEN C%NOTFOUND;
   DBMS_OUTPUT.PUT_LINE(F.DNOMBRE||' '||F.EMPLEADOS);
  END LOOP;
 CLOSE C;
END;

EXECUTE VER_EMPLE_DEPART;

24.
CREATE OR REPLACE PROCEDURE VER_DATOS_EMPLE_POR_DEPART(ND DEPART.DEPT_NO%TYPE)
AS
 CURSOR C IS SELECT * FROM EMPLE WHERE DEPT_NO=ND;
 F C%ROWTYPE;
BEGIN
 OPEN C;
  LOOP
    FETCH C INTO F;
   EXIT WHEN C%NOTFOUND;
   DBMS_OUTPUT.PUT_LINE(F.EMP_NO||' '||F.APELLIDO||' '||F.DEPT_NO);
  END LOOP;
 CLOSE C;
END;

EXECUTE VER_DATOS_EMPLE_POR_DEPART(10);

--MOSTRANDO EL NUMERO DE FILAS QUE YO QUIERA VER
CREATE OR REPLACE PROCEDURE VER_DATOS_EMPLE_POR_DEPART_FILAS(ND DEPART.DEPT_NO%TYPE)
AS
 CURSOR C IS SELECT * FROM EMPLE WHERE DEPT_NO=ND;
 F C%ROWTYPE;
BEGIN
 OPEN C;
  LOOP
    FETCH C INTO F;
   EXIT WHEN C%NOTFOUND OR C%ROWCOUNT>2;
   DBMS_OUTPUT.PUT_LINE(F.EMP_NO||' '||F.APELLIDO||' '||F.DEPT_NO||' '||C%ROWCOUNT);
  END LOOP;
 CLOSE C;
END;

EXECUTE VER_DATOS_EMPLE_POR_DEPART_FILAS(10);


--IGUAL PERO EL CODIGO ESTA SIMPLIFICADO CON FOR IN LOOP,
PERO SE MOSTRARAN TODAS LAS FILA(DE LA PRIMERA HASTA LA ULTIMA, SIN RESTRICCIONES)
CREATE OR REPLACE PROCEDURE VER_DATOS_EMPLE_POR_DEPART_FILAS_SIMPLIFICADO(ND DEPART.DEPT_NO%TYPE)
AS
 CURSOR C IS SELECT * FROM EMPLE WHERE DEPT_NO=ND;
BEGIN
FOR F IN C LOOP
 DBMS_OUTPUT.PUT_LINE(F.EMP_NO||' '||F.APELLIDO||' '||F.DEPT_NO||' '||C%ROWCOUNT);
END LOOP;
END;

EXECUTE VER_DATOS_EMPLE_POR_DEPART_FILAS_SIMPLIFICADO(10);

EJEMPLO PARA SOLLUCIONAR EÑ EJ.25.
--FOR UPDATE:VOY A ACTUALIZAR LA FILA EN LA TABLA (HDD) DONDE ESTÉ 
EL CURSOR(RAM)

--CURRENT OF C:AQUEL REGISTRO QUE SE CORRESPONDA CON EL ACTUAL DEL CURSOR C

--HEMOS CREADO UN BLOQUE ANONIMO, PERO NO UNA FUNCION NI UN PROCEDIMIENTO

--1ª FORMA: FUNCIONA, PERO SE BLOQUEAN TODAS LAS FILAS DEL CURSOR,
MIENTRAS ESTAS SE ESTAN ACTUALIZANDO
DECLARE
 CURSOR C IS SELECT EMP_NO,APELLIDO,SALARIO FROM EMPLE FOR UPDATE;
 SUBIDA NUMBER(7,2);
BEGIN
 FOR FILA IN C LOOP
  SUBIDA:=FILA.SALARIO*10/100;
  IF FILA.SALARIO+SUBIDA<=3000 THEN
  UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE CURRENT OF C;
  END IF;
 END LOOP;
END;

--2ª FORMA: USO DEL IDENTIFICADOR DE FILA(PSEUDOCOLUMNA ROWID)
GRACIAS A ESTO, SOLO SE BLOQUEARA LA FILA QUE SE ESTE PROCESANDO
DECLARE
 CURSOR C IS SELECT EMP_NO,APELLIDO,SALARIO,ROWID FROM EMPLE;
 SUBIDA NUMBER(7,2);
BEGIN
 FOR FILA IN C LOOP
  SUBIDA:=FILA.SALARIO*10/100;
  IF FILA.SALARIO+SUBIDA<=3000 THEN
  UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE ROWID=FILA.ROWID;
  COMMIT;
  END IF;
 END LOOP;
END;

25.
--NO SIEMPRE QUE SE VAN A ACTUALIZAR FILAS, NO ES NECESARIO HACERLO
CON UN CURSOR
PERO ES RECOMENDABLE, YA QUE CON EL CURSOR PODREMOS SABER EL ROWCOUNT
, ES DECIR, EL NUMERO DE FILAS PROCESADAS O ACTUALIZADAS
CREATE OR REPLACE PROCEDURE EJERCICIO25(CD EMPLE.DEPT_NO%TYPE,SUBIDA NUMBER)
AS
BEGIN
 UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA;
END;

--DE ESTA MANERA, DESPUES DEL BUCLE DEL CURSOR(LO ABRE, HACE EL FETCH Y LO CIERRA),
POR LO QUE HAY QUE INGENIERSE COMO SABER EL VALOR DE ROWCOUNT DE NUEVO.
LO UNICO QUE PODEMOS HACER PARA CONTAR EL NUMERO DE FILAS ACTUALIZADAS EN PONER
UNA VARIABLE AL FINAL DEL BUCLE DEL CURSOR
CREATE OR REPLACE PROCEDURE EJERCICIO25(CD EMPLE.DEPT_NO%TYPE,SUBIDA NUMBER)
AS
 CURSOR CUR IS SELECT SALARIO,ROWID FROM EMPLE WHERE DEPT_NO=CD;
 NUMERO_FILAS NUMBER(2);
BEGIN
 FOR FILA IN CUR LOOP
 UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE ROWID=FILA.ROWID;
 NUMERO_FILAS:=CUR%ROWCOUNT;
 END LOOP;
 DBMS_OUTPUT.PUT_LINE('EMPLEADOS ACTUALIZADOS: '||NUMERO_FILAS);
END;

EXECUTE EJERCICIO25(30,50);

--ULTIMA MANERA
CREATE OR REPLACE PROCEDURE EJERCICIO25_1(CD EMPLE.DEPT_NO%TYPE,SUBIDA NUMBER)
AS
 CURSOR CUR IS SELECT SALARIO,ROWID FROM EMPLE WHERE DEPT_NO=CD;
 FILA CUR%ROWTYPE;
BEGIN
 OPEN CUR;
 LOOP
 FETCH CUR INTO FILA;
 EXIT WHEN CUR%NOTFOUND;
 UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE ROWID=FILA.ROWID;
 END LOOP;
 DBMS_OUTPUT.PUT_LINE('EMPLEADOS ACTUALIZADOS: '||CUR%ROWCOUNT);
 CLOSE CUR;
END;

EXECUTE EJERCICIO25_1(30,50);

26.
SELECT * FROM (SELECT * FROM EMPLE ORDER BY SALARIO DESC)
WHERE ROWNUM<=5

--ES MUY IMPORTANTE PONER LAS DOS CONDICIONES DE SALIDA SEPARADAS POR
UN  OR YA QUE SI PONEMOS C1%ROWCOUNT>50, SE MOSTRARAN TODAS LAS QUE 
ENCUENTRE EL CURSOR AUNQUE HAYA 14(NO HACE FALTA QUE HAYA 50 MINIMO O MAS)
CREATE OR REPLACE PROCEDURE EJERCICIO26
AS
CURSOR C1 IS SELECT APELLIDO,SALARIO FROM EMPLE ORDER BY SALARIO DESC;
FI C1%ROWTYPE;
BEGIN
 OPEN C1;
 LOOP
  FETCH C1 INTO FI;
 EXIT WHEN C1%NOTFOUND OR C1%ROWCOUNT>5;
  DBMS_OUTPUT.PUT_LINE(FI.APELLIDO||' '||FI.SALARIO);
 END LOOP;
 CLOSE C1;
END;

EXECUTE EJERCICIO26;

27.
--QTY:CANTIDAD
PCT:PORCENTAJE

CREATE OR REPLACE PROCEDURE EJERCICIO27(
CD EMPLE.DEPT_NO%TYPE,
QTY NUMBER,
PCT NUMBER
)
AS
CURSOR C IS SELECT SALARIO,ROWID FROM EMPLE WHERE DEPT_NO=CD;
SUBIDA NUMBER(6,2);
BEGIN
 FOR F IN C LOOP
  SUBIDA:=GREATEST(QTY,F.SALARIO*PCT/100);
  UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE ROWID=F.ROWID;
  COMMIT;
 END LOOP;
END;

EXECUTE EJERCICIO27(30,50,2);

28.
CREATE OR REPLACE PROCEDURE EJERCICIO28(OFI EMPLE.OFICIO%TYPE)
AS
CURSOR C IS SELECT ROWID,OFICIO,SALARIO FROM EMPLE;
SALARIO_MEDIO_OFICIO NUMBER(6,2);
SUBIDA NUMBER(6,2);
BEGIN
 FOR F IN C LOOP
 COMMIT;
 SELECT AVG(SALARIO) INTO SALARIO_MEDIO_OFICIO FROM EMPLE WHERE OFICIO=F.OFICIO;
 IF F.SALARIO<SALARIO_MEDIO_OFICIO THEN
  SUBIDA:=(SALARIO_MEDIO_OFICIO-F.SALARIO)/2;
  UPDATE EMPLE SET SALARIO=SALARIO+SUBIDA WHERE ROWID=F.ROWID;
  COMMIT;
 END IF;
 COMMIT;
 END LOOP;
END;

EXECUTE EJERCICIO28(VENDEDOR);

29.
CREATE OR REPLACE TRIGGER BORRAR_JUGADOR_EN_ESTADISTICAS
AFTER DELETE ON JUGADORES
FOR EACH ROW
BEGIN
 DELETE FROM ESTADISTICAS WHERE JUGADOR=:OLD.CODIGO;
END;

DELETE FROM JUGADORES WHERE CODIGO=1;

SELECT * FROM JUGADORES;
SELECT * FROM ESTADISTICAS WHERE JUGADOR=1;

ROLLBACK;

30.
CREATE OR REPLACE PROCEDURE MOSTRAR_DATOS_PEDIDO(CODPED JPEDIDOS.CODIGOPEDIDO%TYPE)
AS
 FP DATE;
 FE DATE;
 ES JPEDIDOS.ESTADO%TYPE;
 CLI JPEDIDOS.CODIGOCLIENTE%TYPE;
 NOMCLI VARCHAR2(50);
 DIRCLI VARCHAR2(30);
 CURSOR DET_PEDIDO IS SELECT * FROM JDETALLEPEDIDOS NATURAL JOIN JPRODUCTOS
 WHERE CODIGOPEDIDO=CODPED ORDER BY NUMEROLINEA;
 TOTALPED NUMBER(10,2) DEFAULT 0;
BEGIN
 SELECT FECHAPEDIDO,FECHAENTREGA,ESTADO,CODIGOCLIENTE INTO FP,FE,ES,CLI FROM JPEDIDOS
 WHERE CODIGOPEDIDO=CODPED;
 SELECT NOMBRECLIENTE,LINEADIRECCION1 INTO NOMCLI,DIRCLI FROM JCLIENTES 
 WHERE CODIGOCLIENTE=CLI;
 DBMS_OUTPUT.PUT_LINE('CÓDIGO PEDIDO: '||CODPED);
 DBMS_OUTPUT.PUT_LINE('FECHA PEDIDO: '||FP);
 DBMS_OUTPUT.PUT_LINE('FECHA ENTREGA: '||FE);
 DBMS_OUTPUT.PUT_LINE('ESTADO PEDIDO: '||ES);
 DBMS_OUTPUT.PUT_LINE('CLIENTE: '||NOMCLI);
 DBMS_OUTPUT.PUT_LINE('DIRECCIÓN: '||DIRCLI);
 DBMS_OUTPUT.PUT_LINE('                                          ');
 FOR FILA_DETALLE IN DET_PEDIDO LOOP
  DBMS_OUTPUT.PUT_LINE(FILA_DETALLE.NUMEROLINEA||'.- '||FILA_DETALLE.CODIGOPRODUCTO||' '
  ||FILA_DETALLE.NOMBRE||' '||FILA_DETALLE.CANTIDAD||' '||FILA_DETALLE.PRECIOUNIDAD||' '
  ||FILA_DETALLE.CANTIDAD*FILA_DETALLE.PRECIOUNIDAD);
  TOTALPED:=TOTALPED+FILA_DETALLE.CANTIDAD*FILA_DETALLE.PRECIOUNIDAD;
 END LOOP;
 DBMS_OUTPUT.PUT_LINE('                                          ');
 DBMS_OUTPUT.PUT_LINE('     TOTAL PEDIDO: '||TOTALPED);
 DBMS_OUTPUT.PUT_LINE('     IVA PEDIDO (21%): '||TO_CHAR(TOTALPED*21/100));
 DBMS_OUTPUT.PUT_LINE('     TOTAL PEDIDO CON IVA: '||TO_CHAR(TOTALPED+TOTALPED*21/100));
EXCEPTION
 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('PEDIDO INEXISTENTE');
END;

EXECUTE MOSTRAR_DATOS_PEDIDO(1)

31.
CREATE OR REPLACE PROCEDURE MOSTRAR_PAGOS_CLIENTE(CC JCLIENTES.CODIGOCLIENTE%TYPE)
AS
 NOMCLI VARCHAR2(50);
 TOTALPAGADO NUMBER(8,2);
 CURSOR PAGOS IS SELECT * FROM JPAGOS WHERE CODIGOCLIENTE=CC ORDER BY FECHAPAGO;
BEGIN
 SELECT NOMBRECLIENTE INTO NOMCLI FROM JCLIENTES WHERE CODIGOCLIENTE=CC;
 SELECT SUM(CANTIDAD) INTO TOTALPAGADO FROM JPAGOS WHERE CODIGOCLIENTE=CC;
 DBMS_OUTPUT.PUT_LINE('PAGOS REALIZADOS POR EL CLIENTE: '||NOMCLI);
 DBMS_OUTPUT.PUT_LINE('                                          ');
 FOR FILA_PAGOS IN PAGOS LOOP
  DBMS_OUTPUT.PUT_LINE(FILA_PAGOS.IDTRANSACCION||'-'||FILA_PAGOS.FORMAPAGO||' '
  ||FILA_PAGOS.FECHAPAGO||' '||FILA_PAGOS.CANTIDAD||'€');
 END LOOP;
 DBMS_OUTPUT.PUT_LINE('                                          ');
 DBMS_OUTPUT.PUT_LINE('IMPORTE TOTAL PAGADO POR EL CLIENTE '||NOMCLI||': '||TOTALPAGADO||'€');
EXCEPTION
 WHEN NO_DATA_FOUND THEN
 DBMS_OUTPUT.PUT_LINE('EL CLIENTE NO EXISTE');
END;

EXECUTE MOSTRAR_PAGOS_CLIENTE(1)

SELECT * FROM PAGOS














